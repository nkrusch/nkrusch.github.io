<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><meta name="og:title" content="Neea Rusch" data-next-head=""/><meta name="description" content="Homepage" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><title data-next-head="">Distributing and Parallelizing Non-canonical Loops</title><link rel="preload" href="/_next/static/css/a348b42952ae1530.css" as="style"/><link rel="preload" href="/_next/static/css/2d6c8dafa46e2545.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a348b42952ae1530.css" data-n-g=""/><link rel="stylesheet" href="/_next/static/css/2d6c8dafa46e2545.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-8cac0b4b405cede1.js" defer=""></script><script src="/_next/static/chunks/framework-b80252dbd720399f.js" defer=""></script><script src="/_next/static/chunks/main-d4c20200ddabac7f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8b2b478b1c32f058.js" defer=""></script><script src="/_next/static/chunks/855-3e7c581b3f2344af.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-ed211a0e33ef7f3d.js" defer=""></script><script src="/_next/static/L6lxukodbHLb6QDxjfoop/_buildManifest.js" defer=""></script><script src="/_next/static/L6lxukodbHLb6QDxjfoop/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_container__jQ1_H"><header class="layout_header__iaASZ"><h2 class="utils_headingLg__RYtYb"><a class="utils_colorInherit__Jz9NS" href="/">Neea Rusch</a></h2> </header><main><article><h1 class="utils_headingXl__zlq1q">Distributing and Parallelizing Non-canonical Loops</h1><div class="utils_lightText__B_gv3" style="font-size:90%"><time dateTime="2023-01-16">January 16, 2023</time></div><div><p>I presented this talk at <a href="https://popl23.sigplan.org/home/VMCAI-2023">VMCAI'23</a> in Boston, on January 16, 2023.</p></div><div class="abstract"><h3>Abstract</h3><div><p>This work leverages an original dependency analysis to parallelize loops regardless of their form in imperative programs. Our algorithm distributes a loop into multiple parallelizable loops, resulting in gains in execution time comparable to state-of-the-art automatic source-to-source code transformers when both are applicable. Our graph-based algorithm is intuitive, language-agnostic, proven correct, and applicable to all types of loops. Importantly, it can be applied even if the loop iteration space is unknown statically or at compile time, or more generally if the loop is not in canonical form or contains loop-carried dependency. As contributions we deliver the computational technique, proof of its preservation of semantic correctness, and experimental results to quantify the expected performance gains. We also show that many comparable tools cannot distribute the loops we optimize, and that our technique can be seamlessly integrated into compiler passes or other automatic parallelization suites.</p></div></div><div class="paper"><h3>Paper</h3><a href="https://hal.science/hal-03669387v2/document" target="_blank" nofollow="true" noreferrer="true">https://hal.science/hal-03669387v2/document</a></div><div><h3>Slides</h3><div class="slides ratio_169"><iframe src="../files/vmcai_slides.pdf#view=FitH"></iframe></div><br/><div><a class="button" href="../files/vmcai_slides.pdf" target="_blank">Open in new tab</a><span class="button-spacer"></span><a class="button" href="../files/vmcai_slides.pdf" download="">Download</a></div></div><div></div></article></main><div class="layout_backToHome__uESLU"><a href="/">‚Üê Return</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"2023-vmcai","contentHtml":null,"title":"Distributing and Parallelizing Non-canonical Loops","author":"Neea Rusch","date":"2023-01-16","presentation":true,"embed_title":"Slides","embed":"../files/vmcai_slides.pdf","embed_ratio":"169","paper_title":"https://hal.science/hal-03669387v2/document","paper":"https://hal.science/hal-03669387v2/document","preface":"\u003cp\u003eI presented this talk at \u003ca href=\"https://popl23.sigplan.org/home/VMCAI-2023\"\u003eVMCAI'23\u003c/a\u003e in Boston, on January 16, 2023.\u003c/p\u003e","abstract":"\u003cp\u003eThis work leverages an original dependency analysis to parallelize loops regardless of their form in imperative programs. Our algorithm distributes a loop into multiple parallelizable loops, resulting in gains in execution time comparable to state-of-the-art automatic source-to-source code transformers when both are applicable. Our graph-based algorithm is intuitive, language-agnostic, proven correct, and applicable to all types of loops. Importantly, it can be applied even if the loop iteration space is unknown statically or at compile time, or more generally if the loop is not in canonical form or contains loop-carried dependency. As contributions we deliver the computational technique, proof of its preservation of semantic correctness, and experimental results to quantify the expected performance gains. We also show that many comparable tools cannot distribute the loops we optimize, and that our technique can be seamlessly integrated into compiler passes or other automatic parallelization suites.\u003c/p\u003e","abs_plain":"This work leverages an original dependency analysis to parallelize loops regardless of their form in imperative programs. Our algorithm distributes a loop into multiple parallelizable loops, resulting in gains in execution time comparable to state-of-the-art automatic source-to-source code transformers when both are applicable. Our graph-based algorithm is intuitive, language-agnostic, proven correct, and applicable to all types of loops. Importantly, it can be applied even if the loop iteration space is unknown statically or at compile time, or more generally if the loop is not in canonical form or contains loop-carried dependency. As contributions we deliver the computational technique, proof of its preservation of semantic correctness, and experimental results to quantify the expected performance gains. We also show that many comparable tools cannot distribute the loops we optimize, and that our technique can be seamlessly integrated into compiler passes or other automatic parallelization suites."},"talkData":{"talks":[{"plas":{"title":"An Information Flow Calculus for Non-Interference","url":"2024-plas","where":"Workshop on Programming Languages and Analysis for Security (PLAS)","when":"2024-10-14","location":"Salt Lake City, Utah","icon":"üá∫üá∏"}},{"aalto":{"title":"Implicit Computational Complexity: From Theory to Practice","url":"2024-aalto","where":"Theoretical Computer Science weekly seminar at Aalto University","when":"2024-08-20","location":"Espoo, Finland","icon":"üá´üáÆ"}},{"atva":{"title":"pymwp: A Static Analyzer Determining Polynomial Growth Bounds","url":"2023-atva","where":"International Symposium on Automated Technology for Verification and Analysis (ATVA)","when":"2023-10-25","location":"Singapore","icon":"üá∏üá¨"}},{"scot":{"title":"mwp-Analysis Improvement and Implementation","url":"2023-scot","where":"SCOT Seminar on Semantic and Formal Approaches to Complexity","when":"2023-03-10","location":"online","icon":"üåê"}},{"coqpl":{"title":"Certifying Complexity Analysis","url":"2023-coqpl","where":"International Workshop on Coq for Programming Languages (CoqPL)","when":"2023-01-21","location":"Boston, Massachusetts","icon":"üá∫üá∏"}},{"vmcai":{"title":"Distributing and Parallelizing Non-canonical Loops","url":"2023-vmcai","where":"International Conference on Verification, Model Checking, and Abstract Interpretation (VMCAI)","when":"2023-01-16","location":"Boston, Massachusetts","icon":"üá∫üá∏"}},{"splash":{"title":"Formally Verified Resource Bounds Through Implicit Computational Complexity","url":"2022-splash","where":"Doctoral Symposium at SPLASH","when":"2022-12-06","location":"Auckland, New Zealand","icon":"üá≥üáø"}},{"types":{"title":"Realizing Implicit Computational Complexity","url":"2022-types","where":"International Conference on Types for Proofs and Programs (TYPES)","when":"2022-06-20","location":"Nantes, France","icon":"üá´üá∑"}},{"grd22":{"title":"Semantic-preserving optimization algorithm for automatic program parallelization","url":"2022-graduate-research-day","where":"The 37th Annual Graduate Research Day at Augusta University","when":"2022-04-01","location":"Augusta, Georgia","icon":"üá∫üá∏"}},{"lipn":{"title":"Implementing the mwp-flow analysis","url":"2021-implementing-the-mwp-flow-analysis","where":"IRISA Rennes and LIPN seminars","when":"2021-11-15","location":"Rennes and Paris, France","icon":"üá´üá∑"}},{"grd21":{"title":"Certifying the complexity and correctness of critical software","url":"2021-graduate-research-day","where":"The 36th Annual Graduate Research Day at Augusta University","when":"2021-03-31","location":"online","icon":"üåê"}}]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"2023-vmcai"},"buildId":"L6lxukodbHLb6QDxjfoop","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>